```set template default.html```
```set autoapi ext```
```set tag:defcode gml```
```gmlapi fnames```
```set title steamworks.gml cheat sheet```
```set mainclass boxtt```
```set intro
This is a function "cheat sheet" for Steamworks.gml extension by YellowAfterlife.  
The extension is available [on GitHub](https://github.com/YellowAfterlife/steamworks.gml).  
Example files are available via [itch.io](https://yellowafterlife.itch.io/steamworks-gml-example).  
Donations are accepted via itch.io.  
A most up-to-date version of the manual is always [available online](https://yal.cc/r/17/steamworks-gml/).
```
```set og:url https://yal.cc/r/17/steamworks-gml/```
```set og:desc A Steamworks SDK wrapper for GameMaker!```
```set og:image https://yal.cc/r/17/steamworks-gml/og.png```
```set og:image:width 640```
```set og:image:height 240```
```exec
ref_url = "";
function ref(name) {
	return render("[" + name + "](" + ref_url + "#" + name + ")");
}
function ref_root(label) {
	return render("[" + label + "](" + ref_url + ")");
}
function wrap(name) {
	return render("A wrapper for [" + name + "](" + ref_url + "#" + name + ").");
}
function wrap_url(name, url) {
	return render("A wrapper for [" + name + "](" + url + "#" + name + ").");
}
function ref_set(url) {
	ref_url = url;
	return null;
}
```
```setmd gms2sct
*NOTE:* The following are only available for GMS2/SDK1.42+.
```
```setmd gms2one
*NOTE:* This is only available for GMS2/SDK1.42+.
```
#[General]() {
	#[Setting up Steam](setting-up-steam) {
		See the [official documentation.](https://help.yoyogames.com/hc/en-us/articles/216754138-Using-The-Steamworks-SDK-With-GameMaker-Studio)
		
		Additional note: you can use the test application ID (480) prior to being granted your own application ID, but generally it shouldn't be used for public builds.
	}
	#[Testing games with Steam networking](testing) {
		There are a few things to note about how Steam API works:
		--{
		--	If multiple instances of the same game are ran at once, Steam does not tell them apart, and will send events to whichever happens to ask for them first.
			
			Steam client will generally try to prevent you from opening multiples of the same game, but it's possible when running from editor.
		--	Steam API uses user IDs as endpoints for connections, meaning that you cannot expect reliable results if trying to send something to yourself.
		}
		That said, if you want to test two or more game instances on the same computer, you need to run them through multiple instances of Steam tied to multiple accounts.
		
		Being a single-instance application, Steam will generally not let you open multiple copies of it at once, but that is easily fixed - by using software like [Sandboxie](https://en.wikipedia.org/wiki/Sandboxie) (or equivalent), you can run multiple instances of Steam with separate accounts and game libraries (if needed).
		
		To make the process even more straightforward, you can also run multiple game instances straight from the editor. To do so, you would add a small script to return the combined parameter string for the program,
		```
		/// parameter_string_all()
		var r = "";
		var n = parameter_count();
		for (var i = 0; i < n; i++) {
		    if (i > 0) r += " ";
		    var s = parameter_string(i);
		    if (string_pos(" ", s)) {
		        r += '"' + s + '"';
		    } else r += s;
		}
		return r;
		```
		
		and then copy that string to clipboard,
		```
		clipboard_set_text(parameter_string_all());
		```
		
		on game start (or when other debug condition is met).
		
		Then you would be able to use the copied parameter string to start up additional copies of the game in sandboxed environment(s).
	}
	#[Brief summary on Steam networking](summary) {
		There is a number of things to note about Steam networking compared to regular:
		--{
		--	System is P2P; user IDs are used as endpoints instead of IP+port.
			
			If you need to port existing code utilizing IP+port combinations, you can use bit math to assume lower 32 bits to be the IP and higher 32 bits to be the port, for example.
		--	Steam handles sending/receiving and async events by itself, queuing the results.
			
			This means that you generally should call the extension's update-function ([steam_gml_update]) every step while in lobby and at least once per second while not in lobby, or you may later deal with an avalanche of (outdated) events once finally calling it again.
			
			This schema also introduces an interesting thing where if your game crashed without handling the remaining events/packets, you may receive them after restarting the game.
		--	Steam handles port forwarding by itself, meaning that it'll generally find any open port if there is one, and use a wide variety of workarounds to connect when there isn't one.
			
			In worst case scenario Steam reverts to tunneling (using a Steam server as an intermediate node for connection), but this usually results in fairly high latency.
		--	Related to above, it may take up to 10 seconds to establish connection.
			
			Afterwards, the connection is kept active for as long as anything is sent at least once every 30 seconds or so.
		}
	}
	#[Notes on structs](structs) {
		Some of the extension's functions take and/or return structures.
		
		When using GameMaker Studio 2.3 with [steam_gml_use_structs] enabled,
		these will be represented with GML structs.
		
		Otherwise, they will be represented with arrays where fields are written sequentially.
	}
}
#[General functions](steam_general) {
	#[steam_gml_is_available()->bool]() {
		Returns whether the native extension loaded at all.
	}
	#[steam_gml_is_ready()->bool]() {
		Returns whether the native extension had been loaded and initialized.
		
		*NB!* in GMS2.3, "global" code in scripts runs before extension init does.
	}
	#[steam_gml_check_version()->bool]() {
		Returns whether the native extension is loaded correctly and has it's version matching the one that the game had been built with.
		
		Can be used to timely inform the player that their copy might be broken instead of having them wonder why things are not working.
		```
		if (!steam_gml_check_version()) {
		    show_message("oh no");
		}
		```
	}
	#[steam_gml_update()]() {
		Polls Steam API and dispatches any new events since the last call to the function.
		
		As outlined above, you generally want to call this function every now and then.
	}
}
#[Macros](steam_macros) {
	#[steam_id_use_int64]() {
		*Located in*: `steam_id.gml`
		
		*Default:* `true`
		
		Indicates whether the extension should use 64-bit integers for Steam IDs.
		
		If disabled, the extension will instead represent IDs as two-element array with
		higher/lower 32-bit halves.
		
		Exists only for backwards compatibility and will be removed at some point.
	}
	#[steam_gml_use_structs]() {
		*Located in*: `steam_core.gml`
		
		*Default:* `true`
		
		Indicates whether the extension should use GMS2.3 structs
		(as opposed to arrays)
		to represent multi-value arguments and return types in some cases.
		
		Can be disabled to avoid changing code when migrating from GMS2.2 to GMS2.3+.
	}
}
#[Async events](steam_async) {
	As result of a number of function calls, the extension dispatches asynchronous events.
	```setmd sucres
	`async_load[?"success"]`, `async_load[?"result"]`
	```
	```exec
	function al(key) { return render('`async_load[?"' + key + '"]`');}
	function aid(key) {
	return render('`async_load[?"' + key + '_string"]`')
		+ "<sup>" + render("[\\[id\\]](steam_async_ids)") + "</sup>"
	;}
	```
	
	Where appropriate,
	these events have `async_load[?"success"]` indicating whether the async action succeeded (true or false)
	and `async_load[?"result"]` containing the status code
	(see [EResult](https://partner.steamgames.com/doc/api/steam_api#EResult)).
	
	#[A note on IDs](steam_async_ids) {
		For fields named `some_id_string`,
		the field contains a 64-bit integer converted to a string,
		which you may pass to `int64` to make an actual 64-bit integer out of it;
		there will also be `some_id_high` and `some_id_low` representing the 32-bit
		halves of it, which you can pass to [steam_id_create] or combine yourself via bit operations.
		
		This is due to GameMaker not allowing to include 64-bit integers in async events
	}
	
	These can be caught by adding a Async - Steam event, and checking whether `async_load[?"event_type"]` is one of following names (as strings):
	#[lobby_list]() {
		Triggers after requesting a list of public lobbies via [steam_lobby_list_request].
		
		It is not required to do anything in response to this event.
		
		--{
			- %[sucres]\
			Generally lobby list request can only fail if there's no connection.
			- ${al("lobby_count")}: number of lobbies found.\
			(same as [steam_lobby_list_get_count])
		}
		
		Use [matchmaking functions](steam_lobby_list) to retrieve further information.
	}
	#[lobby_joined]() {
		${wrap_url("LobbyEnter_t", "https://partner.steamgames.com/doc/api/ISteamMatchmaking")}
		
		Triggers after requesting to join a lobby.
		--{
			- %[sucres]\
			An attempt to join a lobby can fail on a few occasions, such as: --{
				- Lack of internet
				- Lack of connection to Steam (inc. maintenance)
				- Lobby being full
				- Lobby getting auto-destroyed by the time you requested to join it\
				(a thing to be aware of when letting the user pick a lobby to join)
			}
			- ${aid("lobby_id")}: ID of lobby joined, if successful.\
			(equivalent to [steam_lobby_get_lobby_id])
		}
		When successful, this is a good place to establish connection to lobby members.
	}
	#[lobby_created]() {
		${wrap_url("LobbyCreated_t", "https://partner.steamgames.com/doc/api/ISteamMatchmaking")}
		
		Triggers after requesting to create a lobby.
		--{
			- %[sucres]\
			Can fail if: --{
				- Lack of connection to Steam (see above)
				- Matchmaking not being enabled for App ID.\
				If you have marked your App ID as free when creating it, matchmaking will be disabled
				and you'll need to request matchmaking permissions from Steam Support.
			}
			- ${aid("lobby_id")}: ID of lobby created, if successful.\
			(equivalent to [steam_lobby_get_lobby_id])
		}
		When successful, this is a good place to [set up lobby data](steam_lobby_set_data).
	}
	#[lobby_join_requested]() {
		${wrap_url("GameLobbyJoinRequested_t", "https://partner.steamgames.com/doc/api/ISteamFriends")}
		
		Triggers when the local player accepts an invitation via Steam overlay.
		
		--{
			- ${aid("lobby_id")}: ID of lobby to be joined\
			(via [steam_lobby_join_id])
			- ${aid("friend_id")}: ID of user that sent the invitation\
			(in case you want to display "joining X's lobby" while loading).
		}
		
		Is commonly used as following:
		```
		if (async_load[?"event_type"] == "lobby_join_requested") {
		    steam_lobby_join_id(steam_id_create(
		        async_load[?"lobby_id_high"],
		        async_load[?"lobby_id_low"]
		    ));
		}
		```
	}
	#[lobby_chat_update]() {
		${wrap_url("LobbyChatUpdate_t", "https://partner.steamgames.com/doc/api/ISteamMatchmaking")}
		
		Triggers upon arrival/departures of players in the lobby.
		--{
			- ${aid("lobby_id")}: ID of lobby in question.
			- ${aid("user_id")}: ID of user that things are happening to.
			- ${aid("change_id")}: ID of user that's authoring the change.
			- ${al("change_flags")}: bit flags for whatever's happening.\
			These can be the following: --{
				- `steam_lobby_member_change_entered`
				- `steam_lobby_member_change_left`
				- `steam_lobby_member_change_disconnected`
				- `steam_lobby_member_change_kicked`
				- `steam_lobby_member_change_banned`
			}
			You may reasonably remark that there are no functions to kick/ban people,
			and, well, there aren't - that's just
			[how Steam API is](https://partner.steamgames.com/doc/api/ISteamMatchmaking#LobbyKicked_t).
			[Always has been](http://web.archive.org/web/20170920175315/https://partner.steamgames.com/doc/api/ISteamMatchmaking#LobbyKicked_t).
		}
	}
	#[lobby_chat_message]() {
		${wrap_url("LobbyChatMsg_t", "https://partner.steamgames.com/doc/api/ISteamMatchmaking")}
		
		Triggers as result of calling [steam_lobby_send_chat_message] or [steam_lobby_send_chat_message_buffer].
		--{
			- ${aid("lobby_id")}: ID of lobby in question.
			- ${aid("user_id")}: ID of user that sent the message.
			- ${al("entry_type")}: a type from [EChatEntryType](https://partner.steamgames.com/doc/api/steam_api#EChatEntryType).\
			There is no evidence that this can be anything other than "normal message".
			- ${al("message_index")}: message index.\
			(for use with [steam_lobby_get_chat_message_text] or [steam_lobby_get_chat_message_data])
			Note that chat messages expire after 3 calls to `steam_gml_update`,
			so you should not be storing this for later use.
			- ${al("message_size")}: size of received message, in bytes.
		}
		Example:
		```
		if (async_load[?"event_type"] == "lobby_chat_message") {
			var _msg_index = async_load[?"message_index"];
			var _from_id = int64(async_load[?"user_id_string"]);
			var _from_name = steam_get_user_persona_name_sync(_from_id);
			var _text = steam_lobby_get_chat_message_text(_msg_index);
			show_debug_message("A chat message from `" + _from_name + "`: " + _text);
		}
		```
	}
	#[p2p_session_request]() {
		${wrap_url("P2PSessionRequest_t", "https://partner.steamgames.com/doc/api/ISteamNetworking")}
		
		If you have opted to handle P2P sessions yourself
		(via [steam_net_set_auto_accept_p2p_sessions]),
		you will want to handle this event for anyone to be able to connect to you.
		--{
			- ${aid("user_id")}: ID of user attempting the connection.
		}
		Example (auto-accept anyone):
		```
		if (async_load[?"event_type"] == "lobby_join_requested") {
			var user_id = steam_id_create(
				async_load[?"user_id_high"],
				async_load[?"user_id_low"]
			);
			steam_net_accept_p2p_session(user_id);
		}
		```
	}
	#[avatar_image_loaded]() {
		${wrap_url("AvatarImageLoaded_t", "https://partner.steamgames.com/doc/api/ISteamFriends")}
		
		Triggers as result of calling [steam_get_user_avatar].
		--{
			- ${aid("user_id")}: ID of the user that avatar was requested for.
			- ${al("image")}: image ID for use with [image functions](steam_avatar).
			- ${al("width")}: width of the image, in pixels.
			- ${al("height")}: height of the image, in pixels.
		}
	}
	#[micro_txn_auth_response]() {
		${wrap_url("MicroTxnAuthorizationResponse_t", "https://partner.steamgames.com/doc/api/ISteamUser")}
		
		--{
			- ${al("success")}: whether the transaction was authorized.
			- ${aid("order_id")}: order ID provided for the microtransaction.
			- ${al("app_id")}: app ID for this microtransaction.
		}
	}
	#[user_encrypted_app_ticket_response_received]() {
		${wrap_url("EncryptedAppTicketResponse_t", "https://partner.steamgames.com/doc/api/ISteamUser")}
		
		Triggers in response to [steam_user_request_encrypted_app_ticket].
		--{
			- %[sucres]
			- ${al("ticket_data")}: base64-encoded binary ticket data.
		}
	}
	#[ugc_delete_item]() {
		${wrap_url("DeleteItemResult_t", "https://partner.steamgames.com/doc/api/ISteamUGC")}
		
		Triggers in response to [steam_ugc_delete_item].
		--{
			- %[sucres]
			- ${aid("published_file_id")}
		}
	}
}
#[Networking functions](steam_net) {
	#[Packet I/O](steam_net_packet) {
		#[steam_net_packet_receive()]() {
			Attempts to get the next packet from Steam API and returns whether successfully done so.
			
			Other `steam_net_` functions can then be used to get packet information/contents.
			
			At most times you would utilize this as following:
			```
			while (steam_net_packet_receive()) {
			    // process the received packet
			}
			```
			(every step while in lobby, less frequently otherwise)
		}
		#[steam_net_packet_get_sender_id()]() {
			Returns Steam ID of the user that sent the last received packet.
			
			Can be used in conjunction with [steam_net_packet_send] to send something back and for just telling the senders apart.
		}
		#[steam_net_packet_get_size()]() {
			Returns the size of last received packet, in bytes.
			
			So, for instance, if you wanted to just display the size of each incoming packet, you could use a snippet of code like the following:
			```
			while (steam_net_packet_receive()) {
			    show_debug_message("Received " + string(steam_net_packet_size()) + " bytes.");
			}
			```
		}
		#[steam_net_packet_get_data(buffer)]() {
			Copies the contents of last received packet to the given buffer.
			
			Data is copied to the start of the buffer (position remains unaffected),
			meaning that if you reuse the same buffer, you should "rewind" it prior to reading.
			
			If the buffer is not big enough to fit data, it will be resized automatically.
			```
			while (steam_net_packet_receive()) {
			    steam_net_packet_get_data(inbuf);
			    buffer_seek(inbuf, buffer_seek_start, 0);
			    switch (buffer_read(inbuf, buffer_u8)) {
			        case 1: show_debug_message("packet ID 1"); break;
			        case 2: show_debug_message("packet ID 2"); break;
			        default: show_debug_message("unknown packet"); break;
			    }
			}
			```
			Whether `inbuf` is a "fixed" or "growing" buffer created on game start for the controller object.
		}
		#[steam_net_packet_send(steam_id, buffer, size, type)]() {
			Sends a packet to the given endpoint, returns whether successful (as opposed to incorrect arguments/invalid ID).
			
			Much as with the built-in `network_send_` functions, this function takes data from the start of the buffer and until the point identified by `size` parameter.
			
			`type` parameter can be one of the following:
			--{
			--	`steam_net_packet_type_unreliable`: roughly equivalent to UDP. May or may not be delivered, will not be resent automatically.
			--	`steam_net_packet_type_unreliable_nodelay`: much like the regular "unreliable" type, but always sent instantly (as soon as function is called). Intended for things like streaming voice data, where you want lowest latency possible and only care about the current data.
			--	`steam_net_packet_type_reliable`: roughly equivalent to TCP. Warranted to be delivered in order and intact.
			--	`steam_net_packet_type_reliable_buffer`: much like the regular "reliable" type, but utilizes [Nagle's algorithm](https://en.wikipedia.org/wiki/Nagle%27s_algorithm) to reduce the number of packets at cost of potential delay while the data accumulates until the sending threshold.
			}
			So you could use it like so:
			```
			var b = buffer_create(16, buffer_grow, 1);
			buffer_write(b, buffer_string, "Hello!");
			steam_net_packet_send(steam_id, b, buffer_tell(b), steam_net_packet_type_reliable);
			buffer_delete(b);
			```
			
			Where `steam_id` would hold the user ID to send the packet to.
		}
	}
	#[P2P sessions](steam_net_p2p) {
		#[steam_net_set_auto_accept_p2p_sessions(enable)]() {
			Sets whether to auto-accept session requests coming from players in the same lobby.
			
			This is enabled by default for convenience.
			
			If you disable it, you will need to handle [p2p_session_request] async event.
		}
		#[steam_net_accept_p2p_session(user_id)]() {
			Accepts a P2P session request from the specified user.
			
			Returns whether successful.
		}
		#[steam_net_close_p2p_session(user_id)]() {
			Closes a P2P session with the specified user.
			
			Steam will automatically close sessions after a period of inactivity,
			but you could also do it manually if you so desired.
			
			Returns whether successful.
		}
	}
}
#[Lobby functions](steam_lobby) {
	The following functions deal with the current lobby.
	```exec
	ref_set("https://partner.steamgames.com/doc/api/ISteamMatchmaking");
	```
	#[steam_lobby_join_id(lobby_id)]() {
		Starts joining a lobby with the given ID.
		
		The operation is carried out asynchronously;
		
		A [lobby_joined] event is dispatched on completion.
		
		See [lobby_join_requested] for a code example.
	}
	#[steam_lobby_create(type, max_members)]() {
		Starts creating a lobby.
		
		The operation is carried out asynchronously;
		
		A [lobby_created] event is dispatched on completion.
		
		`max_members` indicates the maximum allowed number of users in the lobby
		(including the lobby's creator).
		
		`type` can be one of the following:
		--{
		--	`steam_lobby_type_private`: Can only be joined by invitation.
			
			You would usually [change](steam_lobby_set_type) the lobby type to this on match start.
		--	`steam_lobby_type_friends_only`: Can be joined by invitation or via friends-list
		(by opening the user's menu and picking "Join game").
		--	`steam_lobby_type_public`: Can be joined by invitation, via friends-list,
		and shows up in the public lobby list (see [matchmaking](steam_lobby_list) functions).
		}
		Can be used as following:
		```
		steam_lobby_create(steam_lobby_type_public, 4);
		```
		(which would create a 4-player public lobby)
	}
	#[steam_lobby_leave()]() {
		Leaves the current lobby (if any).
		
		Does not raise any errors if currently not in a lobby.
		
		Note that if you are the lobby owner and leave the lobby, Steam transfers lobby ownership to any other available user, so you may need to detect lobby owner changes if any particular logic is handled by them.
	}
	---
	#[steam_lobby_set_type(newtype)]() {
		Changes the lobby's type. You must be the lobby's owner to do this.
		
		Types are the same as per [steam_lobby_create].
		
		So, for example, if you don't allow mid-session joining, you could have the game make lobbies private on session start:
		```
		steam_lobby_set_type(steam_lobby_type_private);
		```
	}
	---
	#[steam_lobby_get_data(key:string)->string]() {
		Returns a lobby field value, as set by [steam_lobby_set_data].
		
		```
		var title = steam_lobby_get_data("title");
		```
	}
	#[steam_lobby_set_data(key:string, value:string)]() {
		Changes a lobby's field. You must be the lobby's owner to do this.
		
		Fields can then be used to filter lobbies via [matchmaking](steam_lobby_list) functions.
		
		*Note*: if your value is numeric, convert it to string prior to passing it to the function.
		
		Otherwise GM will assume your numeric value to be a pointer to a string, which can hard crash your game and/or Steam client.
	}
	---
	#[steam_lobby_is_owner()->bool]() {
		Returns whether the local player is the lobby's owner.
		
		If the lobby is not valid, returns false.
	}
	#[steam_lobby_get_owner_id()->user_id]() {
		Returns the lobby's owner's Steam ID.
		
		If the lobby is not valid, returns ID 0.
	}
	#[steam_lobby_set_owner_id(user_id)->bool]() {
		If you are the lobby owner, transfers the lobby ownership to the specified player,
		which must be in this same lobby.
		
		Returns whether successful.
		
		See remarks in [SetLobbyOwner](https://partner.steamgames.com/doc/api/ISteamMatchmaking#SetLobbyOwner)
	}
	#[steam_lobby_set_joinable(joinable)->bool]() {
		${wrap("SetLobbyJoinable")}
		
		If you are the lobby owner, changes whether the lobby can be joined - be it from lobby list or by invites.
	}
	---
	#[steam_lobby_get_member_count()->int]() {
		Returns the number of users in the current lobby (including you).
		
		If the lobby is not valid, returns 0.
	}
	#[steam_lobby_get_member_id(index)->user_id]() {
		Returns the user ID of the member at the given index in the current lobby.
		
		Index should be between 0 (incl.) and result of [steam_lobby_get_member_count] (excl.). Results will include the local user.
		
		If the index (or lobby) is not valid, returns ID 0.
	}
	---
	#[steam_lobby_get_lobby_id()->lobby_id]() {
		Returns the Steam ID of the current lobby.
	}
	#[steam_lobby_activate_invite_overlay()]() {
		Displays an invitation overlay if currently in a lobby.
		
		The invitation overlay is much akin to friends-list overlay, but only shows online friends, and spots "invite" buttons on each row.
	}
	---
	#[Lobby chat](steam_lobby_chat) {
		${wrap("SendLobbyChatMsg")}
		
		These few functions allow you to send and receive chat messages without
		establishing a P2P connection!
		
		This comes with some caveats: --{
		--	A single message can only be 4KB at most.
		--	Bandwidth is limited (documentation doesn't clarify the limits).
		--	As this sends data via Steam backend, it'll take longer for it to arrive.
		--	Messages are broadcasted to all players in the lobby rather than to the recipient.
		}
		
		Still, this can be handy for any initial communication.
		#[steam_lobby_max_chat_message_size]() {
			Indicates the maximum number of bytes a single lobby message can be (`4096`).
		}
		---
		#[steam_lobby_send_chat_message(text)->bool]() {
			Broadcasts a chat message into the current lobby,
			returns whether successful.
			
			Triggers [lobby_chat_message].
			
			Example: the following would send a message upon joining a lobby and handle the said message:
			```
			// in Async - Steam
			if (async_load[?"event_type"] == "lobby_joined") {
				steam_lobby_send_chat_message("hello!");
			}
			if (async_load[?"event_type"] == "lobby_chat_message") {
				var _msg_index = async_load[?"message_index"];
				var _from_id = int64(async_load[?"user_id_string"]);
				var _from_name = steam_get_user_persona_name_sync(_from_id);
				
				show_debug_message("A chat message from `" + _from_name
					+ "` (text): " + steam_lobby_get_chat_message_text(_msg_index));
			}
			```
		}
		#[steam_lobby_send_chat_message_buffer(buffer, ?size)->bool]() {
			Akin to above, but sends binary data instead.
		}
		The following can only be ran inside an Async - Steam event to work with lobby messages,
		so make sure to copy the results if you'll need them later!
		#[steam_lobby_get_chat_message_size(message_index)->int]() {
			Returns the size of the given lobby message in bytes.
			
			Returns `-1` if the message index is invalid.
		}
		#[steam_lobby_get_chat_message_text(message_index)->string]() {
			Grabs the content of a lobby message as a string.
			
			Returns `""` if the message index is invalid.
			
			If the message was binary, this would result in garbled data up until the first `00` byte
			or until the end of the message.
		}
		#[steam_lobby_get_chat_message_data(message_index, buffer)->bool]() {
			Copies the content of a lobby message into a buffer.
			
			The buffer should be at least [steam_lobby_max_chat_message_size] bytes long,
			or the message will be truncated.
			
			Returns whether the message index was valid.
		}
	}
}
#[Matchmaking functions](steam_lobby_list) {
	The following functions allow retrieving lists of public lobbies.
	#[steam_lobby_list_request()]() {
		Starts loading the list of lobbies matching the current filters.
		
		Filters are reset afterwards and have to be set again for subsequent request(s).
		
		Existing results are kept up until the event is dispatched.
		
		The operation is carried out asynchronously;
		
		A [lobby_list] event is dispatched on completion.
	}
	#[steam_lobby_list_is_loading()]() {
		Returns whether a lobby list request is currently underway.
		
		Is a convenience function - you may as well set a global variable prior to calling [steam_lobby_list_request] and reset in the [lobby_list] event.
	}
	#[Lobby list functions](steam_lobby_list_get) {
		These can be used after receiving a [lobby_list] async event.
		#[steam_lobby_list_get_count()]() {
			Returns the number of lobbies received in the last lobby list request.
			
			For subsequent functions in this section,
			`list_index` should be between 0 (incl.) and the number returned by this function (excl.)
		}
		---
		#[steam_lobby_list_join(list_index)]() {
			Starts joining the lobby at the given index in the list.
			
			See [steam_lobby_join_id] for more information on the process.
		}
		---
		#[steam_lobby_list_get_data(list_index, key:string)->string]() {
			Returns the value of the given field of a lobby at the given index in the current list.
			
			Fields can be set via [steam_lobby_set_data].
			
			*NB!* Value is always returned as a string.
			
			Returns `""` if the lobby does not have the given field set.
		}
		#[steam_lobby_list_get_lobby_id(list_index)->lobby_id]() {
			Returns the Steam ID of the lobby at the given index in the list.
			
			Returns `0` if the index is out of bounds.
		}
		#[steam_lobby_list_get_lobby_owner_id(list_index)->user_id]() {
			Returns the Steam ID of the owner of the lobby at the given index in the list.
			
			Returns `0` if the index is out of bounds.
		}
		#[steam_lobby_list_get_lobby_member_count(list_index)->int]() {
			Returns the number of users in the lobby at the given index in the list.
			
			Returns `0` if the index is out of bounds.
		}
	}
	Requesting:
	#[steam_lobby_list_add_string_filter(key, value, comparison_type)]() {
		Sets up a string filter for the next lobby list request.
		
		That is, lobbies not matching the condition will be excluded from results.
		
		Lobbies without the given field (`key`) will be assumed to have it as "".
		
		The following values can be passed as `comparison_type`:
		--{
		--	`steam_lobby_list_filter_eq`: Equal (`==`).
		--	`steam_lobby_list_filter_ne`: Not-equal (`!=`).
		}
	}
	#[steam_lobby_list_add_numerical_filter(key, value, comparison_type)]() {
		Sets up a numeric filter for the next lobby list request.
		
		That is, lobbies not matching the condition will be excluded from results.
		
		Lobbies without the given field (`key`) will be excluded.
		
		The following values can be passed as `comparison_type`:
		--{
		--	`steam_lobby_list_filter_eq`: Equal (`==`).
		--	`steam_lobby_list_filter_ne`: Not-equal (`!=`).
		--	`steam_lobby_list_filter_lt`: Less-than (`<`).
		--	`steam_lobby_list_filter_gt`: Greater-than (`>`).
		--	`steam_lobby_list_filter_le`: Less-than-or-equal (`<=`).
		--	`steam_lobby_list_filter_ge`: Greater-than-or-equal (`>=`).
		}
	}
	#[steam_lobby_list_add_near_filter(key, value:number)]() {
		Sorts the results based on how close their field's (`key`)'s value is to the provided one.
		
		If multiple near-filters are specified, the earlier-set ones take precedence.
	}
	#[steam_lobby_list_add_distance_filter(mode)]() {
		Restricts results by region and sorts them based on geographical proximity.
		
		The following values can be passed as `mode`:
		--{
		--	`steam_lobby_list_distance_filter_close`: Only allows lobbies in same immediate region.
		--	`steam_lobby_list_distance_filter_default`: Allows lobbies in same or nearby regions (same continent)
		--	`steam_lobby_list_distance_filter_far`: Allows lobbies from up to half-way around the globe (nearby continents).
		--	`steam_lobby_list_distance_filter_worldwide`: Allows any lobbies. May result in very high latencies, so use with care.
		}
	}
}
#[Steam Controller/Input functions](steam_controller_) {
	These have been since renamed to Steam Input in SDK documentation to avoid confusion with Steam Controller device.
	#[General](steam_controller_general) {
		#[steam_controller_init()->success]() {
			Should be called on game start if you intend to use Steam Controller API.
			
			Returns whether successful.
		}
		#[steam_controller_update()]() {
			Is automatically called by [steam_gml_update],
			but can also be called manually to poll data more often.
		}
	}
	#[Controller functions](steam_controller_controller) {
		#[steam_controller_get_ids()->array<controller_id>]() {
			Returns an array of IDs for the connected Steam Controllers.
			
			Such IDs are used for the rest of the functions.
			
			*Note:* You can also use `all` (`-3`) in most controller functions to apply to any/all
			of the connected controllers.
		}
		#[steam_controller_get_ids(arr)->count]() {
			The above function can also be called with an existing array as an argument,
			in which case it will store the IDs in the provided array and return how many it 
			had filled out.
		}
		#[steam_controller_get_type(controller_id)]() {
			Returns Steam-reported type for the given controller.
			
			Values can be: --{
			-- `steam_controller_unknown`
			-- `steam_controller_steam_controller`
			-- `steam_controller_xbox360`
			-- `steam_controller_xboxone`
			-- `steam_controller_generic_xinput`
			-- `steam_controller_ps4`
			-- `steam_controller_apple_mfi`
			-- `steam_controller_android`
			-- `steam_controller_switch_joycon_pair`
			-- `steam_controller_switch_joycon_single`
			-- `steam_controller_switch_pro`
			-- `steam_controller_mobile_touch`
			-- `steam_controller_ps3`
			}
			
			Note that GMS1 / Steamworks1.35a does not support getting controller types and will always return `steam_controller_unknown`.
		}
		#[steam_controller_get_max_count()->int]() {
			Returns how many Steam Input devices can be detected at most.
			
			This is constant per SDK version;
			
			As of writing this in 2021, this is 16.
		}
	}
	#[Action sets](steam_controller_actionset) {
		See [documentation](https://partner.steamgames.com/doc/features/steam_controller/action_set_layers);
		
		#[steam_controller_get_actionset_id(actionset_name)->actionset_id]() {
			Finds an action set ID with given name.
			
			Returns a negative number if such an action set does not exist!
		}
		#[steam_controller_set_actionset(controller_id, actionset_id)->success]() {
			Activates an action set.
			
			*Note:* As of GMS2.3, GameMaker uses Steamworks 1.42, which is not new enough to support action set layers.
			
			`actionset_id` comes from [steam_controller_get_actionset_id].
			
			See [ActivateActionSetLayer](https://partner.steamgames.com/doc/api/ISteamInput#ActivateActionSetLayer).
		}
		#[steam_controller_get_actionset(controller_id)->actionset_id]() {
			Returns the current action set id for a controller, or -1 if it fails (e.g. wrong controller ID).
		}
	}
	#[In-game actions](steam_controller_ingame) {
		See [documentation](https://partner.steamgames.com/doc/features/steam_controller/iga_file);
		
		Digital actions:
		#[steam_controller_get_digital_id(action_name)->digital_id]() {
			Finds a Digital Action ID by its name.
			
			Returns a `>=0` action ID on success, or a negative value on failure.
		}
		#[steam_controller_get_digital_value(controller_id, digital_id)->bool]() {
			Retrieves the current state of a digital action for a controller.
			
			Returns `false` if controller is missing or action ID is invalid.
		}
		#[steam_controller_get_digital_status(controller_id, digital_id)->bool]() {
			Returns whether the given digital action is currently active.
			
			Similarly, returns `false` if controller is missing or action ID is invalid.
		}
		#[steam_controller_get_digital_origins(controller_id, actionset_id, digital_id, ?out:array<origin>)->array<origin>]() {
			Fetches the origins for the specified digital action of an action set for a controller.
			
			The result is an array of origin IDs (see values [here](https://partner.steamgames.com/doc/api/ISteamInput#EInputActionOrigin)) that can then be used to display the correct input prompt.
			
			See [GetDigitalActionOrigins](https://partner.steamgames.com/doc/api/ISteamInput#GetDigitalActionOrigins)
		}
		Analog actions:
		#[steam_controller_get_analog_id(action_name)->analog_id]() {
			Find an Analog Action ID by its name.
			
			Returns a `>=0` action ID on success, or a negative value on failure.
			
			*NB!* Digital and analog action names and IDs can overlap. Don't mix them up!
		}
		#[steam_controller_get_analog_status(controller_id, analog_id)->bool]() {
			Returns whether the given analog action is currently active.
			
			Returns `false` if controller is missing or action ID is invalid.
		}
		#[steam_controller_get_analog_mode(controller_id, analog_id)->mode_id]() {
			Returns the virtual input mode used by an analog action.
			
			See the returned values [here](https://partner.steamgames.com/doc/api/ISteamInput#EControllerSourceMode).
			
			Returns `-1` if controller is missing or action ID is invalid.
		}
		#[steam_controller_get_analog_x(controller_id, analog_id)->number]() {
			Returns the state of an action's horizontal axis.
			
			As per [documentation](https://partner.steamgames.com/doc/api/ISteamInput#InputAnalogActionData_t),
			values depend on configuration - e.g. traditional actions return normalized values in -1..+1 range
			while mouse-like actions provide updates in pixels since the last frame.
			
			Returns `0` if controller is missing or action ID is invalid.
		}
		#[steam_controller_get_analog_y(controller_id, analog_id)->number]() {
			Same as above, but for vertical axis.
			
			Returns `0` if controller is missing or action ID is invalid.
		}
		#[steam_controller_get_analog_origins(controller_id, actionset_id, analog_id, ?out:array<origin>)->array<origin>] {
			Fetches the origins for the specified analog action of an action set for a controller.
			
			The result is an array of origin IDs (see values [here](https://partner.steamgames.com/doc/api/ISteamInput#EInputActionOrigin)) that can then be used to display the correct input prompt.
			
			See [GetAnalogActionOrigins](https://partner.steamgames.com/doc/api/ISteamInput#GetAnalogActionOrigins)
		}
		Misc.:
		#[steam_controller_get_max_origins()->int]() {
			Returns the maximum number of input origins that can be attached to a single action.
			
			This value is constant per SDK version and is set to 8 as of writing this in 2021.
		}
	}
}
#[User/friend functions](steam_user) {
	```exec
	ref_set("https://partner.steamgames.com/doc/api/ISteamFriends");
	```
	#[steam_get_user_persona_name_sync(user_id)]() {
		${wrap("GetFriendPersonaName")}
		Like the built-in `steam_get_user_persona_name`, but returns immediately.
		
		This function will only return names for users that are "known" (e.g. in your lobby).
	}
	#[steam_user_set_played_with(user_id)]() {
		Adds the given user to the "recently played with" list (accessed via "Players" - "Recent games") menu in Steam overlay.
		
		This is usually something to do on session start for all remote users.
	}
	#[steam_get_friends_game_info()->array]() {
		Returns an array of information about what the current user's Steam friends are playing,
		roughly equivalent to what can be seen in Steam Friends UI.
		
		The array contains nested 3-element arrays with the following fields: --{
		--	Steam User ID
		--	Steam Game ID
		--	Steam Lobby ID\
			(if hosting a lobby that is open for friends to join - otherwise `0`)
		}
		This can be used to display an in-game join dialog.
		```
		var info_arr = steam_get_friends_game_info();
		var info_num = array_length(info_arr);
		var _steam_app_id = steam_get_app_id();
		for (var i = 0; i < info_num; i++) {
		    var info = info_arr[i];
		    if (info[1] == _steam_app_id) { // same game!
		        var lobby_id = info[2];
		        if (lobby_id != 0) { // has an open lobby!
		            var user_id = info[0];
		            // use steam_get_user_persona_name(user_id) to grab the name,
		            // store and use steam_lobby_join_id(lobby_id) to join the lobby when asked
		        }
		    }
		}
		```
	}
}
#[Avatar functions](steam_avatar) {
	#[steam_get_user_avatar(user_id, avatar_size)->steam_image_id]() {
		Fetches an avatar for the specified user ID.
		
		`avatar_size` can be: --{
		--	`steam_user_avatar_size_small`: ${wrap("GetSmallFriendAvatar")}
		--	`steam_user_avatar_size_medium`: ${wrap("GetMediumFriendAvatar")}
		--	`steam_user_avatar_size_large`: ${wrap("GetLargeFriendAvatar")}
		}
		
		Returns positive IDs (for use with function below) if the avatar is ready;\
		Returns `0` if no avatar is set for the user;\
		Returns `-1` if the request is pending, triggers a [avatar_image_loaded] event.
	}
	```exec
	ref_set("https://partner.steamgames.com/doc/api/ISteamUtils");
	```
	#[steam_image_get_size(steam_image_id)->]() {
		${wrap("GetImageSize")}
		
		Fetches dimensions for the said Steam image ID.
		
		If the call succeeds, the return value is a two-element array
		containing width and height in pixels.
		
		If the call fails, returns `undefined`.
	}
	#[steam_image_get_rgba(steam_image_id, buffer)->bool]() {
		${wrap("GetImageRGBA")}
		
		Grabs RGBA data of the specified Steam image ID into a GameMaker buffer.
		
		The buffer should be appropriately sized in accordance with
		[steam_image_get_size] (width \* height \* 4).
		
		Returns whether successful.
	}
	#[steam_image_get_bgra(steam_image_id, buffer)->bool]() {
		Like [steam_image_get_rgba],
		but converts the pixels to BGRA format
		(primarily for use with GMS1.4).
	}
	#[steam_image_create_sprite(steam_image_id)->sprite]() {
		A convenience function that grabs the size of the given Steam image ID,
		creates a buffer for it, copies the pixels to the buffer,
		copies the pixels to a surface,
		and creates a sprite out of it.
		
		Returns the newly made sprite ID
		(which you'll want to `sprite_delete` once you're done with it)
		or `-1` if the operation fails.
	}
}
#[Steam Overlay](steam_overlay) {
	#[steam_activate_overlay_raw(raw_name)]() {
		Like GameMaker's `steam_activate_overlay`, but allows to specify any raw names
		from [Steamworks documentation](https://partner.steamgames.com/doc/api/ISteamFriends#ActivateGameOverlay)
		that may not be covered by `ov_` constants.
	}
	#[steam_set_overlay_notification_position(position)]() {
		Changes the corner in which overlay notifications will appear.
		
		Position can be: --{
		--	`steam_overlay_notification_position_top_left`
		--	`steam_overlay_notification_position_top_right`
		--	`steam_overlay_notification_position_bottom_left`
		--	`steam_overlay_notification_position_bottom_right`
		}
		
		This position is per-game and is reset each launch.
	}
	#[steam_set_overlay_notification_inset(hor_inset, vert_inset)]() {
		Sets the inset of the overlay notification from the corner specified by [steam_set_overlay_notification_position].
		
		A value of (0, 0) resets the position into the corner.
		
		This position is per-game and is reset each launch.
	}
}
#[Rich Presence](steam_rich_presence) {
	#[steam_set_rich_presence(key:string, value:string)->bool]() {
		See [SetRichPresence](https://partner.steamgames.com/doc/api/ISteamFriends#SetRichPresence)
		for a comprehensive explanation of things to do with this function.
	}
	#[steam_clear_rich_presence()]() {
		Equivalent of [ClearRichPresence](https://partner.steamgames.com/doc/api/ISteamFriends#ClearRichPresence)
	}
}
#[Steam Inventory](steam_inventory) {
	```setmd inv_result_note
	*NOTE*: You must call [steam_inventory_result_destroy] on the returned async result ID when you are done with it.
	```
	```exec
	ref_set("https://partner.steamgames.com/doc/api/ISteamInventory");
	```
	The following functions allow to use
	[Steam Inventory Service](https://partner.steamgames.com/doc/features/inventory).
	
	Types:
	#[steam_inventory_item_def]() {
		Represents an item type ("item definition number").
		
		Valid definition numbers are between 1 and 999999999;\
		Numbers less than or equal to zero are invalid;\
		Numbers greater than or equal to one billion (1x10^9) are reserved for internal Steam use.
	}
	#[steam_inventory_item_id]() {
		Every individual instance of an item has a globally-unique instance ID.
		
		This ID is unique to the combination of a player and specific item instance,
		and will not be transferred to another player or re-used for another item.
	}
	#[steam_inventory_result]() {
		Many of the functions in this section return a `steam_inventory_result` async result ID.
		
		Invalid results are represented by `-1`, also available as `steam_inventory_result_invalid` constant.
		
		When a result is ready, an async event will be dispatched with: --{
		--	`async_load[?"event_type"]`: `"inventory_result_ready"`
		--	`async_load[?"result"]`: status code as per [steam_inventory_result_get_status].
		--	`async_load[?"handle"]`: the associated async result ID,
			which can be used to tell apart what result this event is for.
		}
		
		The ID can later be found in `async_load[?"handle"]` in inventory-related async events
		and can be polled to retrieve status or returned items.
		
		Async results must be destroyed when you are done using them via [steam_inventory_result_destroy].
		
		#[steam_inventory_result_get_status(inv_result)->int]() {
			${wrap("GetResultStatus")}
			
			Returns status code of a result.
			
			You may opt to use this instead of async events.
			
			Possible values are: --{
				-- `steam_inventory_result_status_pending`
				-- `steam_inventory_result_status_ok`
				-- `steam_inventory_result_status_expired`
				-- `steam_inventory_result_status_invalid`
				-- `steam_inventory_result_status_fail`
				-- `steam_inventory_result_status_invalid_param`
				-- `steam_inventory_result_status_service_unavailable`
				-- `steam_inventory_result_status_limit_exceeded`
			} (see Steam documentation for status code explanations)
		}
		#[steam_inventory_result_destroy(inv_result)->bool]() {
			${wrap("DestroyResult")}
			
			Destroys a result handle and frees all associated memory.
		}
		#[steam_inventory_result_get_unix_timestamp(inv_result)->int]() {
			${wrap("GetResultTimestamp")}
			
			Returns a Unix timestamp for the server time at which the result was generated.
		}
		#[steam_inventory_result_get_item_property(inv_result, item_index:int, prop_name:int)->int]() {
			${wrap("GetResultItemProperty")}
			
			Gets the dynamic properties from an item in an inventory result set.
			
			Property names are always composed of ASCII letters, numbers, and/or underscores.
		}
		#[steam_inventory_result_get_items(inv_result)->array]() {
			${wrap("GetResultItems")}
			
			Get the items associated with an inventory result handle.
			
			This returns an array of [structs] that contain: --{
			--	`item_id`: a [steam_inventory_item_id] representing the item instance.
			--	`item_def`: a [steam_inventory_item_def] representing the item type.
			--	`quantity`: an `int` indicating how many of the said item there is in the slot.
			--	`flags`: see ${ref("ESteamItemFlags")}
			}
		}
	}
	---
	#[steam_inventory_trigger_item_drop(item_def)->steam_inventory_result]() {
		${wrap("TriggerItemDrop")}
		
		%[inv_result_note]
	}
	#[steam_inventory_add_promo_item(item_def)->steam_inventory_result]() {
		${wrap("AddPromoItem")}
		
		%[inv_result_note]
	}
	#[steam_inventory_add_promo_items(item_defs)->steam_inventory_result]() {
		${wrap("AddPromoItems")}
		
		Takes an array of [steam_inventory_item_def]s and grants the user multiple items.
		
		%[inv_result_note]
	}
	#[steam_inventory_consume_item(item_id, quantity)->steam_inventory_result]() {
		${wrap("ConsumeItem")}
		
		%[inv_result_note]
	}
	#[steam_inventory_exchange_items(create_arr, destroy_arr)->steam_inventory_result]() {
		${wrap("ExchangeItems")}
		
		Grants one item in exchange for a set of other items.
		
		`create_arr` is an array of [structs] representing items to be created: --{
		--	`item_def`: a [steam_inventory_item_def] representing the item type
		--	`quantitiy`: number of items of type to be created
		}
		
		`destroy_arr` is an array of structs representing items to be consumed: --{
		--	`item_id`: a [steam_inventory_item_id] of an item to be consumed
		--	`quantity`: how much of the said item is to be consumed
		}
		
		As of writing this, Steam only supports creating one item per call.
		
		See Steam documentation for specifics.
		
		%[inv_result_note]
	}
	#[steam_inventory_generate_items(create_arr)->steam_inventory_result]() {
		${wrap("GenerateItems")}
		
		Generates specific items for the current user.
		
		This is only usable by Steam accounts that belong to the publisher group for your game.
		
		`create_arr` is an array of [structs] representing items to be created: --{
		--	`item_def`: a [steam_inventory_item_def] representing the item type
		--	`quantitiy`: number of items of type to be created
		}
		
		%[inv_result_note]
	}
	#[steam_inventory_start_purchase(purchase_arr)->bool]() {
		${wrap("StartPurchase")}
		
		Opens a Steam Overlay browser for user to purchase specified items.
		The user then may confirm or decline the purchase.
		
		This is only usable by Steam accounts that belong to the publisher group for your game.
		
		`purchase_arr` is an array of [structs] representing items to be purchased: --{
		--	`item_def`: a [steam_inventory_item_def] representing the item type
		--	`quantitiy`: number of items of the type to be purchased
		}
		
		Returns whether the API started opening overlay (which may not happen instantly).
		
		%[gms2one]
	}
	#[steam_inventory_get_all_items()->steam_inventory_result]() {
		${wrap("GetAllItems")}
		
		Starts retrieving all items in the current user's inventory.
		
		%[inv_result_note]
	}
	#[steam_inventory_request_eligible_promo_item_defs(?user_id)->bool]() {
		${wrap("RequestEligiblePromoItemDefinitionsIDs")}
		
		Requests the list of "eligible" promo items that can be manually granted to the given user.
		
		If `user_id` is omitted, the items will be checked for the current user.
		
		Once ready, dispatches an async event with: --{
		--	`async_load[?"event_type"]`: `"inventory_request_eligible_promo_item_defs"`
		--	`async_load[?"user_id_high"]`: First half of the user ID (to be passed to [steam_id_create])
		--	`async_load[?"user_id_low"]`: Second half of the user ID (same as above)
		--	`async_load[?"item_def_count"]`: Number of items returned
		--	`async_load[?"item_def_json"]`: A JSON string with an array of
			[steam_inventory_item_def]s
		--	`async_load[?"is_cached_data"]`: indicates whether the data was retrieved from the cache
			and not from the server
		}
		
		%[gms2one]
	}
	#[steam_inventory_get_items_by_id(item_ids)->steam_inventory_result]() {
		${wrap("GetItemsByID")}
		
		Requests information about a subset of the current user's inventory.
		
		`item_ids` is an array of [steam_inventory_item_id]s.
		
		%[inv_result_note]
	}
	#[steam_inventory_load_item_definitions()->bool]() {
		${wrap("LoadItemDefinitions")}
		
		Triggers an asynchronous load and refresh of item definitions.
		
		Dispatches an async event with `async_load[?"event_type"]` == `"inventory_definition_update"` when done.
	}
	#[Item prices](steam_inventory_price) {
		%[gms2sct]
		
		#[steam_inventory_request_prices()->bool]() {
			${wrap("RequestPrices")}
		}
		#[steam_inventory_get_item_price(item_def:steam_inventory_item_def)->int?]() {
			${wrap("GetItemPrice")}
		}
		#[steam_inventory_get_items_with_prices()->array<any>?]() {
			${wrap("GetItemsWithPrices")}
		}
	}
	#[steam_inventory_transfer_item_quantity(source_item_id, quantity, dest_item_id)->steam_inventory_result]() {
		${wrap("TransferItemQuantity")}
		%[inv_result_note]
	}
	#[Item property updates](steam_inventory_update_) {
		%[gms2sct]
		
		#[steam_inventory_start_update_properties()->steam_inventory_update_handle]() {
			${wrap("StartUpdateProperties")}
			
			Starts a transaction request to update dynamic properties on items for the current user. 
			
			Returns a `steam_inventory_update_handle` that is used in other functions in this section.
		}
		---
		#[steam_inventory_set_property_bool(handle, item_id, prop_name, bool_val)->bool]() {
			${wrap("SetProperty")}
		}
		#[steam_inventory_set_property_float(handle, item_id, prop_name, f32_val)->bool]() {
			Same as above, but for 32-bit floats.
		}
		#[steam_inventory_set_property_int(handle, item_id, prop_name, int_val)->bool]() {
			Same as above, but for 64-bit integers.
		}
		#[steam_inventory_set_property_string(handle, item_id, prop_name, str_val)->bool]() {
			Same as above, but for strings.
		}
		#[steam_inventory_remove_property(handle, item_id, prop_name)->bool]() {
			${wrap("RemoveProperty")}
			
			Removes a dynamic property for the given item.
		}
		---
		#[steam_inventory_submit_update_properties(handle)->steam_inventory_result]() {
			${wrap("SubmitUpdateProperties")}
			
			%[inv_result_note]
		}
	}
}
#[Steam ID functions](steam_id) {
	Functions for handling 64-bit Steam IDs
	#[steam_id_use_int64:bool]() {
		This macro can be flipped to `false` on the `steam_id.gml` file,
		which will cause Steamworks.gml to store Steam IDs as two 32-bit integers
		in a tiny array instead.
		
		This was only useful in REALLY old (1.4.1757 and earlier) versions of GameMaker: Studio
		where 64-bit integer support was occasionally buggy.
	}
	#[steam_id_create(high, low)->steam_id]() {
		Creates a 64-bit ID from two 32-bit halves.
		
		You can see it occasionally used in [async events](steam_async) since GameMaker lacks support
		for dispatching async events with 64-bit integer fields in them.
	}
	#[steam_id_get_high(steam_id)->int]() {
		Returns the higher 32-bit half of a Steam ID.
	}
	#[steam_id_get_low(steam_id)->int]() {
		Returns the lower 32-bit half of a Steam ID.
	}
	#[steam_id_equals(steam_id1, steam_id2)->bool]() {
		Returns whether the two Steam IDs are identical.
		
		(with [steam_id_use_int64] enabled, this is just `steam_id1 == steam_id2`)
	}
	#[steam_id_from_int64(int64)->steam_id]() {
		Converts an int64 to a Steam ID.
		
		(only useful with [steam_id_use_int64] disabled)
	}
	#[steam_id_to_int64(steam_id)->int64]() {
		Converts a Steam ID to an int64.
		
		(only useful with [steam_id_use_int64] disabled)
	}
}
#[Uncommon functions](steam_uncommon) {
	Anything not fitting into the above categories.
	#[steam_ugc_delete_item(published_file_id)]() {
		Attempts deletion of a previously published UGC item.
		
		This will dispatch an async event with: --{
		--	`"event_type"`: `"ugc_delete_item"`
		--	`"success"`: whether deletion succeeded
		--	`"result"`: can offer a more detailed status code if deletion fails
		--	`"published_file_id_high"`
		--	`"published_file_id_low"`
		}
		```
		if (async_load[?"event_type"] == "ugc_delete_item") {
			var file_id = steam_id_create(async_load[?"published_file_id_high"], async_load[?"published_file_id_low"]);
			if (async_load[?"success"]) {
				show_debug_message("Deleted " + string(file_id));
			} else {
				show_debug_message("Failed to delete " + string(file_id)
					+ " - EResult " + string(async_load[?"result"]));
			}
		}
		```
	}
	---
	#[steam_get_app_ownership_ticket_data(buffer, ?app_id)]() {
		Takes a buffer and fills it up with a reasonable "future proof" view of an app ownership ticket for a given app ID.
		
		`buffer` is a buffer to fill up.
		Documentation is not very specific, but it seems like it should be at least 256 bytes long.
		
		`app_id` is the Steam App ID to retrieve ownership data for.
		If not specified, this defaults to `steam_get_app_id()`.
		
		Returns a 5-element array: --{
		--	0: Total number of bytes retrieved (0 if the buffer wasn't large enough).
		--	1: Byte offset for App ID in the buffer.
		--	2: Byte offset for Steam User ID in the buffer.
		--	3: Byte offset for signature in the buffer.
		--	4: Byte length for signature in the buffer.
		}
		
		For example,
		```
		var b = buffer_create(256, buffer_fixed, 1);
		var d = steam_get_app_ownership_ticket_data(b);
		if (d[0] > 0) {
			show_debug_message("App ID: " + string(buffer_peek(b, d[1], buffer_u32)));
			show_debug_message("User ID: " + string(buffer_peek(b, d[2], buffer_u64)));
			show_debug_message("Signature: " + string(d[4]) + "B at ofs:" + string(d[3]));
		} else {
			show_debug_message("Failed to retrieve app ownership data.");
		}
		```
		
		See: [ISteamAppTicket](https://partner.steamgames.com/doc/api/ISteamAppTicket)
	}
	#[steam_user_request_encrypted_app_ticket(?data, ?data_size)]() {
		`data` (optional) is a string or a buffer to include in the resulting buffer.\
		If not specified, defaults to NULL and includes no additional data.
		
		`data_size` (optional) is the number of bytes in `data`.\
		If not specified, this will be set to byte count in a string (not including the final NUL),
		or buffer size.
		
		This function is async.\
		Once ready, it will dispatch the following Async - Steam event: --{
		--	`"event_type"`: will be `"user_encrypted_app_ticket_response_received"`.
		--	`"success"`: will be `true` or `false` depending on whether the operation succeeded.
		--	`"result"`: will hold the extended EResult ID if you need that.
		--	`"ticket_data"`: will hold base64 of returned binary data.\
			You'll probably want to `buffer_base64_decode` it.
		}
		
		For example:
		```
		steam_user_request_encrypted_app_ticket();
		```
		and in Async - Steam:
		```
		if (async_load[?"event_type"] == "user_encrypted_app_ticket_response_received") {
			if (async_load[?"success"]) {
				var buf = buffer_base64_decode(async_load[?"ticket_data"]);
				// ... do something with buf
				buffer_delete(buf);
			} else {
				show_debug_message("Failed to retrieve app ticket - "
					+ string(async_load[?"result"]));
			}
		}
		```
		
		See: [RequestEncryptedAppTicket](https://partner.steamgames.com/doc/api/ISteamUser#RequestEncryptedAppTicket)
		
		Not to be confused with [steam_get_app_ownership_ticket_data]!
	}
}